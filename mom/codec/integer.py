#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2011 Yesudeep Mangalapilly <yesudeep@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
:module: mom.codec.integer
:synopsis: Routines for converting between integers and bytes.

Number-bytes conversion
-----------------------
These codecs are "lossy" as they don't preserve prefixed padding zero bytes.
In a more mathematical sense,

    ``g(f(x))`` is **almost** an identity function, but not exactly.

where ``g`` is the decoder and ``f`` is a encoder.

.. autofunction:: bytes_to_uint
.. autofunction:: uint_to_bytes
"""

# This module contains only the implementations that were bench-marked
# to be the fastest. See _alt_integer.py for alternative but slower
# implementations.

from __future__ import absolute_import, division

try:
    # Utilize psyco if it is available.
    # This should help speed up 32-bit versions of Python if you have
    # psyco installed.
    import psyco
    psyco.full()
except ImportError:
    pass

import binascii
from struct import pack

from mom._compat import get_word_alignment, ZERO_BYTE, EMPTY_BYTE
from mom.builtins import is_bytes, bytes_leading


__all__ = [
    "bytes_to_uint",
    "uint_to_bytes",
]


def bytes_to_uint(raw_bytes):
    """
    Converts bytes to integer::

        bytes_to_integer(bytes) : integer

    This is (essentially) the inverse of integer_to_bytes().

    Encode your Unicode strings to a byte encoding before converting them.

    .. WARNING: Does not preserve leading zero bytes.

    :param raw_bytes:
        Raw bytes (base-256 representation).
    :returns:
        Integer.
    """
    if not is_bytes(raw_bytes):
        raise TypeError("argument must be raw bytes: got %r" %
                        type(raw_bytes).__name__)
    # binascii.b2a_hex is written in C as is int.
    return int(binascii.b2a_hex(raw_bytes), 16)


def uint_to_bytes(number, fill_size=0, chunk_size=0, overflow=False):
    """
    Convert an unsigned integer to bytes (base-256 representation).

    Leading zeros are not preserved for positive integers unless a 
    chunk size or a fill size is specified. A single zero byte is 
    returned if the number is 0 and no padding is specified.

    Specifying a chunk size prefixes enough padding to keep the resulting
    byte size to be a multiple of the chunk size. Filling pads only as 
    much as is required to satisfy the total byte size. The fill size is 
    therefore the maximum size in bytes of the integer. If the number
    of bytes used to represent the integer overflows the fill size, an 
    ``OverflowError`` will be raised. Specifying the ``overflow`` 
    argument to this function by setting it to ``True`` ignores overflow
    errors. In such circumstances, the number of bytes representing the
    integer may be greater than the fill size.

    .. NOTE:
        You cannot specify both the fill size and the chunk size.

    :param number:
        Integer value
    :param fill_size:
        If the optional fill size is given the length of the resulting
        byte string is expected to be the fill size and will be padded
        with prefix zero bytes to satisfy that length.
    :param chunk_size:
        If optional chunk size is given and greater than zero, pad the front of
        the byte string with binary zeros so that the length is a multiple of
        ``chunk_size``.
    :param overflow:
        ``False`` (default). If this is ``True``, no ``OverflowError``
        will be raised when the fill_size is shorter than the length
        of the generated byte sequence. Instead the byte sequence will
        be returned as is.
    :returns:
        Raw bytes (base-256 representation).
    :raises:
        ``OverflowError`` when fill_size is given and the number takes up more
        bytes than fit into the block. This requires the ``overflow``
        argument to this function to be set to ``False`` otherwise, no
        error will be raised.
    """
    if number < 0:
        raise ValueError("Number must be an unsigned integer: %d" % number)

    if fill_size and chunk_size:
        raise ValueError("You can either fill or pad chunks, but not both")

    # Ensure these are integers.
    number & 1 and chunk_size & 1 and fill_size & 1

    raw_bytes = EMPTY_BYTE

    # Pack the integer one machine word at a time into bytes.
    num = number
    word_bits, _, max_uint, pack_type = get_word_alignment(num)
    pack_format = ">%s" % pack_type
    while num > 0:
        raw_bytes = pack(pack_format, num & max_uint) + raw_bytes
        num >>= word_bits
    # Obtain the index of the first non-zero byte.
    zero_leading = bytes_leading(raw_bytes)
    if number == 0:
        raw_bytes = ZERO_BYTE
    # De-padding.
    raw_bytes = raw_bytes[zero_leading:]

    length = len(raw_bytes)
    if fill_size > 0:
        if not overflow and length > fill_size:
            raise OverflowError(
                "Need %d bytes for number, but fill size is %d" %
                (length, fill_size)
            )
        raw_bytes = raw_bytes.rjust(fill_size, ZERO_BYTE)
    elif chunk_size > 0:
        remainder = length % chunk_size
        if remainder:
            padding_size = chunk_size - remainder
            raw_bytes = raw_bytes.rjust(length + padding_size, ZERO_BYTE)
    return raw_bytes
